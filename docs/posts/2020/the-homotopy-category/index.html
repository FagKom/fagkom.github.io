<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>The homotopy category | Writing what I&#39;m learning</title>
<meta name="keywords" content="Homotopy, Homotopy category, Model categories, Derived categories" />
<meta name="description" content="This is part 9 of a series leading up to and exploring model categories. For the other parts see 1, 2, 3, 4, 5 6, 7 and 8.
Last time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting.">
<meta name="author" content="Torgeir Aambø">
<link rel="canonical" href="https://torgeiraamboe.github.io/posts/2020/the-homotopy-category/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.c40e68a68dca4b02b290eb889994cee9d437b4b85f8ae52bb2b4b945a9bf5d9b.css" integrity="sha256-xA5opo3KSwKykOuImZTO6dQ3tLhfiuUrsrS5Ram/XZs=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://torgeiraamboe.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://torgeiraamboe.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://torgeiraamboe.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://torgeiraamboe.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://torgeiraamboe.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.82.1" />
<head>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  
  <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
  <script>
    MathJax = {
      tex: {
        inlineMath: [
          ['$', '$'], ['\\(', '\\)']
        ],
        processEscapes: true,
        processEnvironments: true
      },
      options: {
        skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
      }
    };
  </script>




<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4GPE516BB"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-Z4GPE516BB');
</script>
</head>


<script async src="https://www.googletagmanager.com/gtag/js?id=G-Z4GPE516BB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-Z4GPE516BB', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="The homotopy category" />
<meta property="og:description" content="This is part 9 of a series leading up to and exploring model categories. For the other parts see 1, 2, 3, 4, 5 6, 7 and 8.
Last time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://torgeiraamboe.github.io/posts/2020/the-homotopy-category/" />
<meta property="og:image" content="https://torgeiraamboe.github.io/images/homclasses.png" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-14T00:00:00&#43;00:00" />
<meta property="article:modified_time" content="2020-06-14T00:00:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://torgeiraamboe.github.io/images/homclasses.png" />
<meta name="twitter:title" content="The homotopy category"/>
<meta name="twitter:description" content="This is part 9 of a series leading up to and exploring model categories. For the other parts see 1, 2, 3, 4, 5 6, 7 and 8.
Last time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://torgeiraamboe.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "The homotopy category",
      "item": "https://torgeiraamboe.github.io/posts/2020/the-homotopy-category/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "The homotopy category",
  "name": "The homotopy category",
  "description": "This is part 9 of a series leading up to and exploring model categories. For the other parts see 1, 2, 3, 4, 5 6, 7 and 8.\nLast time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting.",
  "keywords": [
    "Homotopy", "Homotopy category", "Model categories", "Derived categories"
  ],
  "articleBody": "This is part 9 of a series leading up to and exploring model categories. For the other parts see 1, 2, 3, 4, 5 6, 7 and 8.\nLast time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting. The goal is to have a well defined workable notion of a homotopy category, and understand what it consists of.\nMotivation In topological spaces, there are two ways to make a homotopy category. The first one is called the naive homotopy category and is made by having the same objects, i.e. all topological spaces, but instead of all maps we have homotopy classes of maps. As the name implies, the resulting category isn’t very well behaved in the way we want it to. Quillen introduced a better definition which is made through localization. Localization is defined by formally inverting a class of maps such that they become isomorphisms. The resulting category after localizing at the class of weak homotopy equivalences is called the Quillen homotopy category of topological spaces, or just the homotopy category. When actually working with the naive homotopy category, there are some alterations we can do to make the situation better. If we encounter a bad object that does not play nice, we replace it by a CW-approximation via a weak homotopy equivalence, which by the CW-approximation theorem always exists. There is also a famous theorem by Whitehead, called naturally the Whitehead theorem, which states that “two CW-complexes are weakly homotopy equivalent if and only if they are homotopy equivalent”. Hence, when we take homotopy classes of maps, every weak homotopy equivalence between CW-complexes will end up in the same equivalence class as an isomorphism, which makes weakly homotopy equivalent spaces isomorphic. Now we have two categories that are very similar, and these will be our motivation throughout.\nThe homotopy categegory Before we do anything else we define the homotopy category of a model category in the general setting, not just for topological spaces.\nDefinition (homotopy category): The homotopy category of a model category $\\mathscr{C}$ is defined to be the Quillen homotopy category of $\\mathscr{C}$, i.e. $Ho(\\mathscr{C})= W^{-1}\\mathscr{C}$ where $W$ is the collection of weak equivalences in the model structure.\nThis definition does not give us much in terms of workability. Even though we called it naive, we really like homotopy classes of maps, and this definition of a homotopy category does not reflect the definition we gave of homotopy at all. As we see, the homotopy category is purely dependent on the class of weak equivalences and doesn’t on the surface have anything to do with homotopy. But, as we will see soon, homotopy classes of maps do play a role here, but we got to do some work to show it.\nAs said earlier, we left of with the definition of homotopy in a model category. To mimic topological spaces we need this definition of homotopy to satisfy some properties, at least working nice with composition, having a notion of homotopy equivalence between objects and hopefully have some abstracted version of the Whitehead theorem to tell us we are one the right track. We didn’t show that left and right homotopies work nicely with composition, but I don’t think it is that hard to imagine, hence we leave it out to focus on the more important bits.\nDefinition (homotopy equivalence): We say two bifibrant spaces $X$ and $Y$ are homotopy equivalent if there exists morphisms $f:X\\rightarrow Y$ and $g:Y\\rightarrow X$ such that $g\\circ f \\sim id_X$ and $f\\circ g \\sim id_Y$.\nIn the Serre model structure on topological spaces the cofibrant objects are exactly the CW-complexes, and any object is fibrant. Hence, we can reformulate the Whitehead theorem as “two bifibrant objects are weakly homotopy equivalent if and only if they are homotopy equivalent”. This is starting to look like a general theorem that tells us that a nice definition of homotopy which leads to a nice notion of homotopy equivalence will in fact coincide with the pre-chosen class of weak equivalences when restricted to the class of “homotopy-nice” objects. This is the theorem that tells us we are on the right track towards a workable version of the naive homotopy category, because when we localize at the weak equivalences in the Quillen homotopy category, the homotopy equivalent objects will turn into isomorphic objects.\nThe generalized Whitehead theorem: Any two bifibrant objects in a model category $\\mathscr{C}$ are weakly equivalent if and only if they are homotopy equivalent.\nNow we are getting somewhere! Localizing at the weak equivalences also turns homotopy equivalences of bifibrant objects into isomorphisms! We are getting closer to a workable nice category. Now we have a subcategory of bifibrant objects, which we denote $\\mathscr{C}_ {b}$ or more standard $\\mathscr{C}_{cf}$, with a notion of homotopy being an equivalence relation, denoted $\\sim$. Hence we can form its naive homotopy category $\\mathscr{C}_b\\rightarrow \\mathscr{C}_b/\\sim$. By the generalized Whitehead theorem the map sends weak equivalences to isomorphisms, and hence it has to factor through its Quillen homotopy category $Ho(\\mathscr{C}_b)$. We also have an inclusion $\\mathscr{C}_b \\rightarrow \\mathscr{C}$ which induces a map on their Quillen homotopy categories, i.e. $Ho(\\mathscr{C}_b)\\rightarrow Ho(\\mathscr{C})$. The final piece of the puzzle of having a workable homotopy category will come from the fact that those maps form an equivalence of categories $Ho(\\mathscr{C})\\cong \\mathscr{C}_b/\\sim$, which means we have both a nice definition, and a nice way to work with it. I must admit I don’t fully understand the proof yet, hence I leave it out for now, but I will hopefully post an update with just this proof in the future.\nThis final theorem also means that we have isomorphisms\nwhere $A^{cf}$ means we have taken both a cofibrant followed by a fibrant replacement of $X$. I include this as a picture since this article had none, and I need a coverphoto… Also pictures are more fun.\nThe reader might be confused as to why the naive homotopy category of topological spaces exists, and why we don’t really need to pass down to only CW complexes. Recall that in the Strøm model structure on the category of topological spaces, all objects are both fibrant and cofibrant, hence localization at the homotopy equivalences results in the same category as just taking homotopy classes of maps. Hence, the naive homotopy category is the Quillen homotopy category of topological spaces with the Strøm model structure, while the “true” homotopy category is the Quillen homotopy category of topological spaces with the Serre model structure. This shows in my opinion that the Serre model structure is a bit nicer, but also more restrictive.\nDerived categories The algebraically inclined reader familiar with homological algebra will recognize the definition of the Quillen homotopy category as very similar to the derived category of a ring, or in general the derived category of an abelian category. As mentioned in part 7, an example of a model category is the category of chain complexes of modules over some ring, and localizing this category at its weak equivalences, namely the quasi isomorphisms gives the derived category of the ring, i.e. $D(R)=Q^{-1}C(ModR)$ where $Q$ is the class of quasi isomorphisms. Usually the reason for introducing the derived category in homological algebra is that working with chain homotopy classes of maps in chain complexes does not work nicely with the triangulated structure that naturally arises. In particular, a short exact sequence in the category of chain complexes may not be a distinguished triangle in the “homotopy category”. By homotopy category I here mean the category of chain complexes of modules over a ring with maps being chain homotopy classes of chain maps. This should rather be called the naive homotopy category, since it is exactly the same construction that we did for topological spaces. Passing to the derived category rectifies this, since every exact sequence gives a distinguished triangle. We will probably explore triangulated categories more in the fall, as I am going to follow a course focusing on them.\nIn the model structure on chain complexes of modules over a ring, the injective and projective resolutions are the fibrant and cofibrant replacements. We have showed that homotopy classes of maps between bifibrant objects gives an equivalent naive homotopy category to the Quillen homotopy category of the entire category, hence if we take an Abelian category with enough projectives and enough injectives, all objects have nice replacements that we can work with, and if we restrict ourselves to just these projective and injective chain complexes we have an equivalent category to the derived category that is more workable.\nNext time we will study functors between model categories, and what it means to preserve the model structure. We will also study what type of functor we need to make sure that both model categories have an equivalent homotopy category. As a teaser, derived functors will be an example of functors between model categories.\n",
  "wordCount" : "1514",
  "inLanguage": "en",
  "image":"https://torgeiraamboe.github.io/images/homclasses.png","datePublished": "2020-06-14T00:00:00Z",
  "dateModified": "2020-06-14T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Torgeir Aambø"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://torgeiraamboe.github.io/posts/2020/the-homotopy-category/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Writing what I'm learning",
    "logo": {
      "@type": "ImageObject",
      "url": "https://torgeiraamboe.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://torgeiraamboe.github.io/" accesskey="h" title="Writing what I&#39;m learning (Alt + H)">Writing what I&#39;m learning</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://folk.ntnu.no/torgeaam/" title="My homepage">
                    <span>My homepage</span>
                </a>
            </li>
            <li>
                <a href="https://torgeiraamboe.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://torgeiraamboe.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://torgeiraamboe.github.io/archives/" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://torgeiraamboe.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://torgeiraamboe.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://torgeiraamboe.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      The homotopy category
    </h1>
    <div class="post-meta">June 14, 2020&nbsp;·&nbsp;8 min&nbsp;·&nbsp;Torgeir Aambø
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#motivation" aria-label="Motivation">Motivation</a></li>
                <li>
                    <a href="#the-homotopy-categegory" aria-label="The homotopy categegory">The homotopy categegory</a></li>
                <li>
                    <a href="#derived-categories" aria-label="Derived categories">Derived categories</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>This is part 9 of a series leading up to and exploring model categories. For the other parts see 
<a href="https://torgeiraamboe.github.io/posts/2020/fibrations/">1</a>,
<a href="https://torgeiraamboe.github.io/posts/2020/fiber-bundles/">2</a>,
<a href="https://torgeiraamboe.github.io/posts/2020/homotopy-groups/">3</a>,
<a href="https://torgeiraamboe.github.io/posts/2020/the-serre-spectral-sequence/">4</a>,
<a href="https://torgeiraamboe.github.io/posts/2020/a-homotopy-group-of-a-sphere/">5</a>
<a href="https://torgeiraamboe.github.io/posts/2020/cofibrations/">6</a>,
<a href="https://torgeiraamboe.github.io/posts/2020/model-categories/">7</a> and
<a href="https://torgeiraamboe.github.io/posts/2020/homotopy-in-model-categories/">8</a>.</p>
<p>Last time we ended by giving a definition of a homotopy between maps on the collection of bifibrant objects in a model category. Today we are going to expand further upon this idea, and try to build the theory we are familiar with for topological spaces but in the general setting. The goal is to have a well defined workable notion of a homotopy category, and understand what it consists of.</p>
<h2 id="motivation">Motivation<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h2>
<p>In topological spaces, there are two ways to make a homotopy category. The first one is called the naive homotopy category and is made by having the same objects, i.e. all topological spaces, but instead of all maps we have homotopy classes of maps. As the name implies, the resulting category isn’t very well behaved in the way we want it to. Quillen introduced a better definition which is made through localization. Localization is defined by formally inverting a class of maps such that they become isomorphisms. The resulting category after localizing at the class of weak homotopy equivalences is called the Quillen homotopy category of topological spaces, or just the homotopy category. When actually working with the naive homotopy category, there are some alterations we can do to make the situation better. If we encounter a bad object that does not play nice, we replace it by a CW-approximation via a weak homotopy equivalence, which by the CW-approximation theorem always exists. There is also a famous theorem by Whitehead, called naturally the Whitehead theorem, which states that “two CW-complexes are weakly homotopy equivalent if and only if they are homotopy equivalent”. Hence, when we take homotopy classes of maps, every weak homotopy equivalence between CW-complexes will end up in the same equivalence class as an isomorphism, which makes weakly homotopy equivalent spaces isomorphic. Now we have two categories that are very similar, and these will be our motivation throughout.</p>
<h2 id="the-homotopy-categegory">The homotopy categegory<a hidden class="anchor" aria-hidden="true" href="#the-homotopy-categegory">#</a></h2>
<p>Before we do anything else we define the homotopy category of a model category in the general setting, not just for topological spaces.</p>
<p><strong>Definition (homotopy category):</strong> The homotopy category of a model category $\mathscr{C}$ is defined to be the Quillen homotopy category of $\mathscr{C}$, i.e. $Ho(\mathscr{C})= W^{-1}\mathscr{C}$ where $W$ is the collection of weak equivalences in the model structure.</p>
<p>This definition does not give us much in terms of workability. Even though we called it naive, we really like homotopy classes of maps, and this definition of a homotopy category does not reflect the definition we gave of homotopy at all. As we see, the homotopy category is purely dependent on the class of weak equivalences and doesn’t on the surface have anything to do with homotopy. But, as we will see soon, homotopy classes of maps do play a role here, but we got to do some work to show it.</p>
<p>As said earlier, we left of with the definition of homotopy in a model category. To mimic topological spaces we need this definition of homotopy to satisfy some properties, at least working nice with composition, having a notion of homotopy equivalence between objects and hopefully have some abstracted version of the Whitehead theorem to tell us we are one the right track. We didn’t show that left and right homotopies work nicely with composition, but I don’t think it is that hard to imagine, hence we leave it out to focus on the more important bits.</p>
<p><strong>Definition (homotopy equivalence):</strong> We say two bifibrant spaces $X$ and $Y$ are homotopy equivalent if there exists morphisms $f:X\rightarrow Y$ and $g:Y\rightarrow X$ such that $g\circ f \sim id_X$ and $f\circ g \sim id_Y$.</p>
<p>In the Serre model structure on topological spaces the cofibrant objects are exactly the CW-complexes, and any object is fibrant. Hence, we can reformulate the Whitehead theorem as “two bifibrant objects are weakly homotopy equivalent if and only if they are homotopy equivalent”. This is starting to look like a general theorem that tells us that a nice definition of homotopy which leads to a nice notion of homotopy equivalence will in fact coincide with the pre-chosen class of weak equivalences when restricted to the class of “homotopy-nice” objects. This is the theorem that tells us we are on the right track towards a workable version of the naive homotopy category, because when we localize at the weak equivalences in the Quillen homotopy category, the homotopy equivalent objects will turn into isomorphic objects.</p>
<p><strong>The generalized Whitehead theorem:</strong> Any two bifibrant objects in a model category $\mathscr{C}$ are weakly equivalent if and only if they are homotopy equivalent.</p>
<p>Now we are getting somewhere! Localizing at the weak equivalences also turns homotopy equivalences of bifibrant objects into isomorphisms! We are getting closer to a workable nice category. Now we have a subcategory of bifibrant objects, which we denote $\mathscr{C}_ {b}$ or more standard $\mathscr{C}_{cf}$, with a notion of homotopy being an equivalence relation, denoted $\sim$. Hence we can form its naive homotopy category $\mathscr{C}_b\rightarrow \mathscr{C}_b/\sim$. By the generalized Whitehead theorem the map sends weak equivalences to isomorphisms, and hence it has to factor through its Quillen homotopy category $Ho(\mathscr{C}_b)$. We also have an inclusion $\mathscr{C}_b \rightarrow \mathscr{C}$ which induces a map on their Quillen homotopy categories, i.e. $Ho(\mathscr{C}_b)\rightarrow Ho(\mathscr{C})$. The final piece of the puzzle of having a workable homotopy category will come from the fact that those maps form an equivalence of categories $Ho(\mathscr{C})\cong \mathscr{C}_b/\sim$, which means we have both a nice definition, and a nice way to work with it. I must admit I don’t fully understand the proof yet, hence I leave it out for now, but I will hopefully post an update with just this proof in the future.</p>
<p>This final theorem also means that we have isomorphisms</p>
<p><img loading="lazy" src="images/homclasses.png" alt="Error loading image"  />
</p>
<p>where $A^{cf}$ means we have taken both a cofibrant followed by a fibrant replacement of $X$. I include this as a picture since this article had none, and I need a coverphoto… Also pictures are more fun.</p>
<p>The reader might be confused as to why the naive homotopy category of topological spaces exists, and why we don’t really need to pass down to only CW complexes. Recall that in the Strøm model structure on the category of topological spaces, all objects are both fibrant and cofibrant, hence localization at the homotopy equivalences results in the same category as just taking homotopy classes of maps. Hence, the naive homotopy category is the Quillen homotopy category of topological spaces with the Strøm model structure, while the “true” homotopy category is the Quillen homotopy category of topological spaces with the Serre model structure. This shows in my opinion that the Serre model structure is a bit nicer, but also more restrictive.</p>
<h2 id="derived-categories">Derived categories<a hidden class="anchor" aria-hidden="true" href="#derived-categories">#</a></h2>
<p>The algebraically inclined reader familiar with homological algebra will recognize the definition of the Quillen homotopy category as very similar to the derived category of a ring, or in general the derived category of an abelian category. As mentioned in part 7, an example of a model category is the category of chain complexes of modules over some ring, and localizing this category at its weak equivalences, namely the quasi isomorphisms gives the derived category of the ring, i.e. $D(R)=Q^{-1}C(ModR)$ where $Q$ is the class of quasi isomorphisms. Usually the reason for introducing the derived category in homological algebra is that working with chain homotopy classes of maps in chain complexes does not work nicely with the triangulated structure that naturally arises. In particular, a short exact sequence in the category of chain complexes may not be a distinguished triangle in the “homotopy category”. By homotopy category I here mean the category of chain complexes of modules over a ring with maps being chain homotopy classes of chain maps. This should rather be called the naive homotopy category, since it is exactly the same construction that we did for topological spaces. Passing to the derived category rectifies this, since every exact sequence gives a distinguished triangle. We will probably explore triangulated categories more in the fall, as I am going to follow a course focusing on them.</p>
<p>In the model structure on chain complexes of modules over a ring, the injective and projective resolutions are the fibrant and cofibrant replacements. We have showed that homotopy classes of maps between bifibrant objects gives an equivalent naive homotopy category to the Quillen homotopy category of the entire category, hence if we take an Abelian category with enough projectives and enough injectives, all objects have nice replacements that we can work with, and if we restrict ourselves to just these projective and injective chain complexes we have an equivalent category to the derived category that is more workable.</p>
<p>Next time we will study functors between model categories, and what it means to preserve the model structure. We will also study what type of functor we need to make sure that both model categories have an equivalent homotopy category. As a teaser, derived functors will be an example of functors between model categories.</p>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://torgeiraamboe.github.io/tags/homotopy/">Homotopy</a></li>
      <li><a href="https://torgeiraamboe.github.io/tags/homotopy-category/">Homotopy category</a></li>
      <li><a href="https://torgeiraamboe.github.io/tags/model-categories/">Model categories</a></li>
      <li><a href="https://torgeiraamboe.github.io/tags/derived-categories/">Derived categories</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://torgeiraamboe.github.io/posts/2020/swans-theorem/">
    <span class="title">« Prev Page</span>
    <br>
    <span>Swans Theorem</span>
  </a>
  <a class="next" href="https://torgeiraamboe.github.io/posts/2020/homotopy-in-model-categories/">
    <span class="title">Next Page »</span>
    <br>
    <span>Homotopy in model categories</span>
  </a>
</nav>

<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on twitter"
        href="https://twitter.com/intent/tweet/?text=The%20homotopy%20category&amp;url=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f&amp;hashtags=Homotopy%2cHomotopycategory%2cModelcategories%2cDerivedcategories">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f&amp;title=The%20homotopy%20category&amp;summary=The%20homotopy%20category&amp;source=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f&title=The%20homotopy%20category">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on whatsapp"
        href="https://api.whatsapp.com/send?text=The%20homotopy%20category%20-%20https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share The homotopy category on telegram"
        href="https://telegram.me/share/url?text=The%20homotopy%20category&amp;url=https%3a%2f%2ftorgeiraamboe.github.io%2fposts%2f2020%2fthe-homotopy-category%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span></span>
    
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    let menu = document.getElementById('menu')
    menu.scrollLeft = localStorage.getItem("menu-scroll-position");
    menu.onscroll = function () {
        localStorage.setItem("menu-scroll-position", menu.scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>




</html>

